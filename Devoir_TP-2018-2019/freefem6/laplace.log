-- FreeFem++ v  3.610001 (date jeu. 12 juil. 2018 15:05:23)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : //verbosity 0;
    2 :
    3 : // Trace de l'√©x√©cution dans un fichier
    4 : ofstream tfile("output/laplace_trace_umfpack.txt");
    5 : // Fichier de sortie sous forme de tableau pour trac√© gnuplot
    6 : ofstream gfile("output/laplace_errors_umfpack.txt");
    7 :
    8 : tfile << "Probleme de Laplace" << endl;
    9 :
   10 : gfile << "# Resolution de -Laplacien(u) = f avec u = 0 au b
  ... : ord" << endl;
   11 : gfile << "# sur le carre [0,1]x[0,1] en elements finis P1 L
  ... : agrange" << endl;
   12 : gfile << "# sur une suite de maillages" << endl;
   13 : gfile << "# et pour une solution analytique quadratique en
  ... : x et y" << endl;
   14 :
   15 : gfile << "# r anisotrope, erreur L^2 relative, erreur relat
  ... : ive L^2 sur le gradient, temps CPU" << endl;
   16 :
   17 : // D√©finition des bord du domaine de calcul
   18 : border Gamma1(t=0,1) {x=t; y=0;};
   19 : border Gamma2(t=0,1) {x=1; y=t;};
   20 : border Gamma3(t=0,1) {x=1-t; y=1;};
   21 : border Gamma4(t=0,1) {x=0; y=1-t;};
   22 :
   23 : // fixe maillage de rafinement
   24 : int k=5;
   25 :
   26 : real[int] aniso(3);
   27 : aniso = [1,3,6];
   28 : // Boucle sur une famille de valeur de diagonal a(x)
   29 : for (int i=0;i<aniso.n;++i)
   30 :   {
   31 :     // Construction du maillage
   32 :     int n = 10*2^k; // Nombre de points par c√¥t√©
   33 :     real t1 = clock(); // Pour mesure du temps cpu
   34 :     mesh Th = buildmesh(Gamma1(n)+Gamma2(n)+Gamma3(n)+Gamma4(n));
   35 :
   36 :     tfile << "  Nombre de sommets par cote : " << n << endl;
   37 :     tfile << "  Nombre de sommets dans le maillage : " << Th.nv << endl;
   38 :     tfile << "  Nombre de triangles dans le maillage : " << Th.nt << endl;
   39 :
   40 :     // Affichage et sortie fichierdu maillage seul
   41 :     //plot(Gamma1(n)+Gamma2(n)+Gamma3(n)+Gamma4(n));
   42 :     //plot(Th, wait=1, ps="laplace.eps");
   43 :
   44 :     // D√©finition de l'espace de discr√©tisation. Ici on discr√©tise
   45 :     // V=H^1_0(\Omega) avec des √©l√©ments finis P1-Lagrange
   46 :     fespace Vh(Th,P1);
   47 :     tfile << "  Nombre de degres de liberte : " << Vh.ndof << endl;
   48 :
   49 :     cout << "*** k = " << k << " --> n = " << n << " , #DOf = " << Vh.ndof << " ***" << endl;
   50 :
   51 :     // D√©finition de la formulation variationnelle dans Vh
   52 :
   53 :     // On a besoin de 2 fonctions u et v dans Vh
   54 :     Vh u,v;
   55 :
   56 :     real rr=aniso[i];
   57 :     tfile << "r = " << rr << endl;
   58 :
   59 :     // D'une fonction definie de mani√®re analytique (pour le second membre)
   60 :     func f = 4*pi*pi*(1+10^rr)*sin(2*pi*x)*sin(2*pi*y);
   61 :     // Qui s'annule bien au bord du domaine et dont la solution (de
   62 :     // -Laplacien(u)=f) est $u(x,y) = sin(2*pi*x)*sin(2*pi*y);
   63 :
   64 :     // Voici finalement notre probl√®me, avec son solveur lin√©aire
   65 :     problem laplace(u,v,solver=UMFPACK) = int2d(Th)( dx(u)*dx(v) + 10^rr * dy(u)*dy(v) )
   66 :       - int2d(Th)( f*v ) + on(Gamma1,Gamma2,Gamma3,Gamma4,u=0);
   67 :
   68 :     // R√©solution du syst√®me lin√©aire
   69 :     laplace;
   70 :
   71 :     // Visualisation de la solution
   72 :     //plot(u, fill=true,value=true,boundary=true,wait=true);
   73 :
   74 :     // Solution exacte projetee dans Vh
   75 :     Vh ue, dxue, dyue;
   76 :     ue = sin(2*pi*x)*sin(2*pi*y); // Expression de la solution exacte
   77 : //    dxue = 2*pi*cos(2*pi*x)*sin(2*pi*y);
   78 : //    dyue = 2*pi*sin(2*pi*x)*cos(2*pi*y);
   79 :
   80 :     // Calcul des erreurs
   81 :     real normeL2, errL2, normeH1, errH1, normeH1n, errH1n;
   82 :     normeL2 = sqrt( int2d(Th) ( (ue)^2 ) );
   83 :     errL2   = sqrt( int2d(Th) ( (u-ue)^2 ) );
   84 :
   85 :     normeH1 = sqrt( int2d(Th) ( (ue)^2 ) + int2d(Th) ( (dx(ue))^2 ) + int2d(Th) ( (dy(ue))^2 ));
   86 :     errH1   = sqrt( int2d(Th) ( (u-ue)^2 ) + int2d(Th) ( (dx(u)-dx(ue))^2 ) + int2d(Th) ( (dy(u)-dy(ue))^2 ));
 
   87 :
   88 :
   89 :     real t2 = clock(); // Pour mesure du temps cpu
   90 :     tfile << "  Erreur L2 relative : " << errL2/normeL2 << endl;
   91 :     tfile << "  Erreur H1 relative : " << errH1/normeH1 << endl;
   92 :     tfile << "  Temps CPU total : " << t2-t1 << endl;
   93 :     tfile << "  min(u) : " << u[].min << "  max(u) : " << u[].max << "  min(ue) : " << ue[].min << "  max(ue) :
" << ue[].max << endl;
   94 :
   95 :
   96 :     gfile << rr << "  " << errL2/normeL2 << "  " << errH1/normeH1 << "  " << t2-t1 << endl;
   97 : //    gfile << 1./n << "  " << errH1/normeH1 << "  " << t2-t1 << endl;
   98 :   }
   99 :  sizestack + 1024 =5336  ( 4312 )
 
  --  mesh:  Nb of Triangles = 243846, Nb of Vertices 122564
*** k = 5 --> n = 320 , #DOf = 122564 ***
  -- Solve :
          min -1.00004  max 0.99997
  --  mesh:  Nb of Triangles = 243846, Nb of Vertices 122564
*** k = 5 --> n = 320 , #DOf = 122564 ***
^C try getConsole C:\Users\PC\Desktop\MN&CHP_UniversitÈ-De-Bordeaux\Projet_MNEIncompresible\Devoir_TP\freefem6\laplace.edp
